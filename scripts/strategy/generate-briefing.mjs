#!/usr/bin/env node

import { readFile, writeFile, mkdir } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');

const valuationPath = path.resolve(repoRoot, '../valuation/edulure-prelaunch-valuation.md');
const markdown = await readFile(valuationPath, 'utf8');
const generatedAt = new Date().toISOString();

function extractSummary() {
  const midpointMatch = markdown.match(/- \*\*Estimated pre-launch equity value \(midpoint\):\s*([^*]+)\*\*/);
  const rangeMatch = markdown.match(/- \*\*Valuation range:\*\*\s*([^\n]+)/);
  const dateMatch = markdown.match(/- \*\*Valuation date:\*\*\s*([^\n]+)/);
  return {
    midpoint: midpointMatch ? midpointMatch[1].trim() : null,
    range: rangeMatch ? rangeMatch[1].trim() : null,
    valuationDate: dateMatch ? dateMatch[1].trim() : null
  };
}

function extractSection(startHeading) {
  const startIndex = markdown.indexOf(startHeading);
  if (startIndex === -1) {
    return '';
  }
  const remainder = markdown.slice(startIndex + startHeading.length);
  const nextHeadingMatch = remainder.match(/\n##\s+/);
  const endIndex = nextHeadingMatch ? remainder.indexOf(nextHeadingMatch[0]) : remainder.length;
  return remainder.slice(0, endIndex).trim();
}

function collectBulletedBlocks(section) {
  const lines = section.split('\n');
  const blocks = [];
  let current = null;

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      continue;
    }

    if (line.startsWith('- ')) {
      if (current) {
        blocks.push(current.trim());
      }
      current = line.slice(2).trim();
    } else if (current) {
      current += ` ${line}`;
    }
  }

  if (current) {
    blocks.push(current.trim());
  }

  return blocks;
}

function collectOrderedBlocks(section) {
  const lines = section.split('\n');
  const blocks = [];
  let current = null;

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      continue;
    }

    if (/^\d+\.\s+/.test(line)) {
      if (current) {
        blocks.push(current.trim());
      }
      current = line.replace(/^\d+\.\s+/, '').trim();
    } else if (current) {
      current += ` ${line}`;
    }
  }

  if (current) {
    blocks.push(current.trim());
  }

  return blocks;
}

function extractCapabilitySignals() {
  const section = extractSection('## Feature and capability profile');
  const lines = section.split('\n').filter((line) => line.trim().startsWith('|'));
  if (lines.length <= 2) {
    return [];
  }
  const rows = lines.slice(2); // skip header and separator
  return rows
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((line) => {
      const cells = line.split('|').slice(1, 4).map((cell) => cell.trim());
      if (cells.length < 3) {
        return null;
      }
      return {
        area: cells[0],
        signals: cells[1],
        impact: cells[2]
      };
    })
    .filter(Boolean);
}

function extractRiskAdjustments() {
  const section = extractSection('## Risk adjustments');
  const blocks = collectBulletedBlocks(section);
  return blocks
    .map((block) => {
      if (!block.startsWith('**')) {
        return null;
      }
      const withoutPrefix = block.slice(2);
      const [emphasised, remainder = ''] = withoutPrefix.split('**', 2);
      if (!emphasised) {
        return null;
      }
      const headline = emphasised.trim().replace(/:+$/, '').trim();
      const open = headline.lastIndexOf('(');
      const close = headline.lastIndexOf(')');
      if (open === -1 || close === -1 || close <= open) {
        return null;
      }
      const label = headline.slice(0, open).trim();
      const impact = headline.slice(open + 1, close).trim();
      const narrative = remainder.replace(/^:\s*/, '').trim();
      return {
        label: label.trim(),
        impact: impact.trim(),
        narrative: narrative.trim()
      };
    })
    .filter(Boolean);
}

function extractRecommendations() {
  const section = extractSection('## Recommendations');
  const blocks = collectOrderedBlocks(section);
  return blocks.map((entry) => entry.trim());
}

const summary = extractSummary();
const capabilitySignals = extractCapabilitySignals();
const riskAdjustments = extractRiskAdjustments();
const recommendations = extractRecommendations();

const payload = {
  generatedAt,
  summary,
  capabilitySignals,
  riskAdjustments,
  recommendations
};

async function writeJson(relativePath) {
  const destination = path.resolve(repoRoot, '..', relativePath);
  await mkdir(path.dirname(destination), { recursive: true });
  await writeFile(destination, `${JSON.stringify(payload, null, 2)}\n`, 'utf8');
}

function buildTypeScriptModule() {
  const lines = [
    '/* eslint-disable */',
    '// This file is generated by scripts/strategy/generate-briefing.mjs.',
    `export const strategyBriefing = ${JSON.stringify(payload, null, 2)} as const;`,
    '',
    'export type StrategyBriefing = typeof strategyBriefing;',
    '',
    'export function getStrategySummary() {',
    '  return strategyBriefing.summary;',
    '}',
    '',
    'export function listCapabilitySignals() {',
    '  return strategyBriefing.capabilitySignals;',
    '}',
    '',
    'export function listRiskAdjustments() {',
    '  return strategyBriefing.riskAdjustments;',
    '}',
    '',
    'export function listRecommendations() {',
    '  return strategyBriefing.recommendations;',
    '}',
    ''
  ];
  return `${lines.join('\n')}\n`;
}

function escapeDartString(value) {
  return value.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

function buildDartModule() {
  const summaryEntries = Object.entries(summary)
    .map(([key, value]) => `    '${key}': '${value ? escapeDartString(value) : ''}',`)
    .join('\n');
  const capabilityEntries = capabilitySignals
    .map(
      (item) =>
        `    <String, String>{'area': '${escapeDartString(item.area)}', 'signals': '${escapeDartString(item.signals)}', 'impact': '${escapeDartString(item.impact)}'},`
    )
    .join('\n');
  const riskEntries = riskAdjustments
    .map(
      (item) =>
        `    <String, String>{'label': '${escapeDartString(item.label)}', 'impact': '${escapeDartString(item.impact)}', 'narrative': '${escapeDartString(item.narrative)}'},`
    )
    .join('\n');
  const recommendationEntries = recommendations
    .map((item) => `    '${escapeDartString(item)}',`)
    .join('\n');

  const content = `// GENERATED FILE - DO NOT EDIT DIRECTLY.\n// Generated by scripts/strategy/generate-briefing.mjs on ${generatedAt}.\nclass StrategyBriefingData {\n  static const Map<String, String> summary = <String, String>{\n${summaryEntries}\n  };\n\n  static const List<Map<String, String>> capabilitySignals = <Map<String, String>>[\n${capabilityEntries}\n  ];\n\n  static const List<Map<String, String>> riskAdjustments = <Map<String, String>>[\n${riskEntries}\n  ];\n\n  static const List<String> recommendations = <String>[\n${recommendationEntries}\n  ];\n}\n`;
  return content;
}

await writeJson('backend-nodejs/src/data/navigationStrategyBriefing.json');
await writeJson('frontend-reactjs/src/data/navigationStrategyBriefing.json');
await writeJson('docs/operations/generated/navigation-strategy-briefing.json');
await writeFile(
  path.resolve(repoRoot, '../sdk-typescript/src/runtime/strategyBriefing.ts'),
  buildTypeScriptModule(),
  'utf8'
);
await writeFile(
  path.resolve(repoRoot, '../Edulure-Flutter/lib/core/strategy_briefing.dart'),
  `${buildDartModule()}\n`,
  'utf8'
);

console.log('Strategy briefing generated.');
