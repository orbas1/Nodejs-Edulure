#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const repoRoot = path.resolve(__dirname, '..');
const tokensPath = path.join(repoRoot, 'docs', 'design-system', 'design_tokens.json');
const researchInsightsPath = path.join(repoRoot, 'docs', 'design-system', 'research_insights.json');
const cssOutputPath = path.join(repoRoot, 'frontend-reactjs', 'src', 'styles', 'tokens.css');
const dartOutputPath = path.join(repoRoot, 'Edulure-Flutter', 'lib', 'core', 'design_tokens.dart');
const sqlSeedOutputPath = path.join(
  repoRoot,
  'backend-nodejs',
  'database',
  'seeders',
  '004_seed_design_system_assets.sql'
);

const tokens = JSON.parse(fs.readFileSync(tokensPath, 'utf8'));
const researchInsights = JSON.parse(fs.readFileSync(researchInsightsPath, 'utf8'));

const headerComment = `/*
 * -----------------------------------------------------------------------------
 *  This file is generated by scripts/sync-design-tokens.cjs.
 *  Do not edit directly â€“ update docs/design-system/design_tokens.json instead.
 * -----------------------------------------------------------------------------
 */\n`;

function cssBlock(selector, declarations, indentLevel = 0) {
  const indent = '  '.repeat(indentLevel);
  const innerIndent = '  '.repeat(indentLevel + 1);
  const lines = Object.entries(declarations)
    .map(([key, value]) => `${innerIndent}${key}: ${value};`)
    .join('\n');
  return `${indent}${selector} {\n${lines}\n${indent}}\n`;
}

function buildCss(json) {
  const parts = [headerComment, cssBlock(':root', json.base || {}) + '\n'];

  const overrides = json.overrides || {};
  for (const [atRule, selectorMap] of Object.entries(overrides)) {
    parts.push(`${atRule} {\n`);
    for (const [selector, declarations] of Object.entries(selectorMap)) {
      parts.push(cssBlock(selector, declarations, 1) + '\n');
    }
    parts.push('}\n\n');
  }

  const dataOverrides = json.dataOverrides || {};
  for (const [selector, declarations] of Object.entries(dataOverrides)) {
    parts.push(cssBlock(selector, declarations) + '\n');
  }

  return parts.join('').trimEnd() + '\n';
}

function toCamelCase(token) {
  return token.replace(/^--/, '').replace(/-([a-z0-9])/g, (_, char) => char.toUpperCase());
}

function withPrefix(name, prefix) {
  if (!prefix) {
    return name;
  }
  return prefix + name.charAt(0).toUpperCase() + name.slice(1);
}

function formatDouble(num) {
  const fixed = Number(num.toFixed(4));
  if (Number.isInteger(fixed)) {
    return `${fixed.toFixed(1)}`;
  }
  return `${fixed}`;
}

function parseNumeric(raw) {
  const trimmed = raw.trim();
  if (/^-?\d+(?:\.\d+)?rem$/i.test(trimmed)) {
    return formatDouble(parseFloat(trimmed.replace(/rem/i, '')) * 16);
  }
  if (/^-?\d+(?:\.\d+)?px$/i.test(trimmed)) {
    return formatDouble(parseFloat(trimmed.replace(/px/i, '')));
  }
  if (/^-?\d+(?:\.\d+)?\s*\/\s*-?\d+(?:\.\d+)?$/.test(trimmed)) {
    const [numerator, denominator] = trimmed.split('/').map((segment) => parseFloat(segment.trim()));
    return formatDouble(numerator / denominator);
  }
  if (/^-?\d+(?:\.\d+)?$/.test(trimmed)) {
    return formatDouble(parseFloat(trimmed));
  }
  return null;
}

function parseTokenValue(key, rawValue) {
  if (!key.startsWith('--')) {
    return null;
  }

  if (typeof rawValue === 'number') {
    return { type: 'double', value: formatDouble(rawValue) };
  }

  const value = String(rawValue).trim();
  if (/^#([0-9a-f]{6})$/i.test(value)) {
    return { type: 'color', value: `Color(0xFF${value.slice(1).toUpperCase()})` };
  }

  const rgbaMatch = value.match(/^rgba?\(([^)]+)\)$/i);
  if (rgbaMatch) {
    const parts = rgbaMatch[1].split(',').map((segment) => segment.trim());
    const [r, g, b] = parts;
    const alpha = parts[3] !== undefined ? parseFloat(parts[3]) : 1;
    return { type: 'color', value: `Color.fromRGBO(${parseInt(r, 10)}, ${parseInt(g, 10)}, ${parseInt(b, 10)}, ${alpha})` };
  }

  if (/^cubic-bezier\(([^)]+)\)$/i.test(value)) {
    const [x1, y1, x2, y2] = value
      .replace(/cubic-bezier\(|\)/gi, '')
      .split(',')
      .map((segment) => Number(segment.trim()));
    return { type: 'cubic', value: `Cubic(${x1}, ${y1}, ${x2}, ${y2})` };
  }

  if (/^\d+ms$/i.test(value)) {
    const ms = parseInt(value.replace(/ms/i, ''), 10);
    return { type: 'duration', value: `Duration(milliseconds: ${ms})` };
  }

  const numeric = parseNumeric(value);
  if (numeric !== null) {
    return { type: 'double', value: numeric };
  }

  return { type: 'string', value: `'${value.replace(/\\/g, '\\\\').replace(/'/g, "\\'")}'` };
}

function transformTokens(map, prefix = '') {
  const results = [];
  for (const [key, rawValue] of Object.entries(map)) {
    const parsed = parseTokenValue(key, rawValue);
    if (!parsed) {
      continue;
    }
    const camel = toCamelCase(key);
    const name = withPrefix(camel, prefix);
    results.push({ name, ...parsed });
  }
  return results;
}

function buildDart(json) {
  const imports = "import 'package:flutter/material.dart';\n\n";
  const baseTokens = transformTokens(json.base || {});
  const darkTokens = transformTokens(((json.overrides || {})['@media (prefers-color-scheme: dark)'] || {})[':root'] || {}, 'dark');
  const contrastTokens = transformTokens(((json.overrides || {})['@media (prefers-contrast: more)'] || {})[':root'] || {}, 'contrast');

  const lines = [
    '// GENERATED CODE - DO NOT MODIFY BY HAND.',
    '// Generated by scripts/sync-design-tokens.cjs from docs/design-system/design_tokens.json.',
    imports,
    'class DesignTokens {',
    '  DesignTokens._();',
  ];

  function pushConst({ name, type, value }) {
    let dartType = type;
    if (type === 'color') {
      dartType = 'Color';
    } else if (type === 'double') {
      dartType = 'double';
    } else if (type === 'duration') {
      dartType = 'Duration';
    } else if (type === 'cubic') {
      dartType = 'Cubic';
    } else if (type === 'string') {
      dartType = 'String';
    }
    lines.push(`  static const ${dartType} ${name} = ${value};`);
  }

  [...baseTokens, ...darkTokens, ...contrastTokens].forEach((token) => pushConst(token));

  lines.push('', '  static ThemeData lightTheme(TextTheme textTheme) {');
  lines.push('    return ThemeData(');
  lines.push('      colorScheme: ColorScheme(');
  lines.push('        brightness: Brightness.light,');
  lines.push('        primary: colorPrimary,');
  lines.push('        onPrimary: Colors.white,');
  lines.push('        secondary: colorEmerald,');
  lines.push('        onSecondary: Colors.white,');
  lines.push('        surface: colorSurface,');
  lines.push('        onSurface: colorText,');
  lines.push('        background: colorSurfaceMuted,');
  lines.push('        onBackground: colorText,');
  lines.push('        error: colorRose,');
  lines.push('        onError: Colors.white,');
  lines.push('      ),');
  lines.push('      scaffoldBackgroundColor: colorSurface,');
  lines.push('      textTheme: textTheme,');
  lines.push('      useMaterial3: true,');
  lines.push('      inputDecorationTheme: InputDecorationTheme(');
  lines.push('        filled: true,');
  lines.push('        fillColor: formFieldSurface,');
  lines.push('        contentPadding: EdgeInsets.symmetric(');
  lines.push('          horizontal: formFieldPaddingX,');
  lines.push('          vertical: formFieldPaddingY,');
  lines.push('        ),');
  lines.push('        enabledBorder: OutlineInputBorder(');
  lines.push('          borderRadius: BorderRadius.circular(radiusLg),');
  lines.push('          borderSide: BorderSide(color: formFieldBorder),');
  lines.push('        ),');
  lines.push('        focusedBorder: OutlineInputBorder(');
  lines.push('          borderRadius: BorderRadius.circular(radiusLg),');
  lines.push('          borderSide: BorderSide(color: formFieldBorderStrong),');
  lines.push('        ),');
  lines.push('      ),');
  lines.push('      elevatedButtonTheme: ElevatedButtonThemeData(');
  lines.push('        style: ElevatedButton.styleFrom(');
  lines.push('          padding: EdgeInsets.symmetric(');
  lines.push('            horizontal: space6,');
  lines.push('            vertical: space3,');
  lines.push('          ),');
  lines.push('          shape: RoundedRectangleBorder(');
  lines.push('            borderRadius: BorderRadius.circular(radiusXl),');
  lines.push('          ),');
  lines.push('        ),');
  lines.push('      ),');
  lines.push('    );');
  lines.push('  }', '');

  lines.push('  static ThemeData darkTheme(TextTheme textTheme) {');
  lines.push('    return ThemeData(');
  lines.push('      colorScheme: ColorScheme(');
  lines.push('        brightness: Brightness.dark,');
  lines.push('        primary: colorPrimary,');
  lines.push('        onPrimary: Colors.white,');
  lines.push('        secondary: colorEmerald,');
  lines.push('        onSecondary: Colors.white,');
  lines.push('        surface: darkColorSurface,');
  lines.push('        onSurface: darkColorText,');
  lines.push('        background: darkColorSurfaceMuted,');
  lines.push('        onBackground: darkColorText,');
  lines.push('        error: colorRose,');
  lines.push('        onError: Colors.white,');
  lines.push('      ),');
  lines.push('      scaffoldBackgroundColor: darkColorSurface,');
  lines.push('      textTheme: textTheme,');
  lines.push('      useMaterial3: true,');
  lines.push('      inputDecorationTheme: InputDecorationTheme(');
  lines.push('        filled: true,');
  lines.push('        fillColor: darkFormFieldSurface,');
  lines.push('        contentPadding: EdgeInsets.symmetric(');
  lines.push('          horizontal: formFieldPaddingX,');
  lines.push('          vertical: formFieldPaddingY,');
  lines.push('        ),');
  lines.push('        enabledBorder: OutlineInputBorder(');
  lines.push('          borderRadius: BorderRadius.circular(radiusLg),');
  lines.push('          borderSide: BorderSide(color: darkFormFieldBorder),');
  lines.push('        ),');
  lines.push('        focusedBorder: OutlineInputBorder(');
  lines.push('          borderRadius: BorderRadius.circular(radiusLg),');
  lines.push('          borderSide: BorderSide(color: darkFormFieldBorderStrong),');
  lines.push('        ),');
  lines.push('      ),');
  lines.push('    );');
  lines.push('  }', '');

  lines.push('  static ThemeData highContrastTheme(TextTheme textTheme) {');
  lines.push('    return ThemeData(');
  lines.push('      colorScheme: ColorScheme(');
  lines.push('        brightness: Brightness.light,');
  lines.push('        primary: contrastColorPrimary,');
  lines.push('        onPrimary: Colors.white,');
  lines.push('        secondary: colorEmerald,');
  lines.push('        onSecondary: Colors.white,');
  lines.push('        surface: contrastColorSurface,');
  lines.push('        onSurface: contrastColorText,');
  lines.push('        background: contrastColorSurfaceMuted,');
  lines.push('        onBackground: contrastColorText,');
  lines.push('        error: colorRose,');
  lines.push('        onError: Colors.white,');
  lines.push('      ),');
  lines.push('      scaffoldBackgroundColor: contrastColorSurface,');
  lines.push('      textTheme: textTheme.apply(bodyColor: contrastColorText, displayColor: contrastColorText),');
  lines.push('      useMaterial3: true,');
  lines.push('      elevatedButtonTheme: ElevatedButtonThemeData(');
  lines.push('        style: ElevatedButton.styleFrom(');
  lines.push('          padding: EdgeInsets.symmetric(');
  lines.push('            horizontal: space6,');
  lines.push('            vertical: space3,');
  lines.push('          ),');
  lines.push('          shape: RoundedRectangleBorder(');
  lines.push('            borderRadius: BorderRadius.circular(radiusXl),');
  lines.push('          ),');
  lines.push('        ),');
  lines.push('      ),');
  lines.push('    );');
  lines.push('  }');

  lines.push('}');

  return lines.join('\n') + '\n';
}

function categoriseToken(key) {
  if (!key || typeof key !== 'string') {
    return 'general';
  }
  const trimmed = key.replace(/^--/, '');
  const [segment] = trimmed.split('-');
  const known = new Set([
    'color',
    'gradient',
    'shadow',
    'font',
    'space',
    'radius',
    'screen',
    'form',
    'motion',
    'media',
    'skeleton',
    'overlay',
    'grid'
  ]);
  return known.has(segment) ? segment : 'general';
}

function flattenTokenRecords(json) {
  const records = [];
  let order = 1;

  const pushRecord = ({ key, value, source, context = null, selector }) => {
    if (!key || value === undefined || value === null) {
      return;
    }
    records.push({
      token_key: key,
      token_value: String(value),
      source,
      context,
      selector,
      token_category: categoriseToken(key),
      display_order: order++,
      metadata: {
        version: json.version ?? null,
        source,
        context,
        selector
      }
    });
  };

  const base = json.base ?? {};
  for (const [key, value] of Object.entries(base)) {
    pushRecord({ key, value, source: 'base', context: null, selector: ':root' });
  }

  const overrides = json.overrides ?? {};
  for (const [atRule, selectorMap] of Object.entries(overrides)) {
    for (const [selector, declarations] of Object.entries(selectorMap ?? {})) {
      for (const [key, value] of Object.entries(declarations ?? {})) {
        pushRecord({ key, value, source: 'media', context: atRule, selector });
      }
    }
  }

  const dataOverrides = json.dataOverrides ?? {};
  for (const [selector, declarations] of Object.entries(dataOverrides)) {
    for (const [key, value] of Object.entries(declarations ?? {})) {
      pushRecord({ key, value, source: 'data', context: null, selector });
    }
  }

  return records;
}

function buildResearchRecords(json) {
  const version = json.version ?? null;
  return (json.insights ?? []).map((insight, index) => ({
    slug: insight.slug,
    title: insight.title,
    status: insight.status,
    recorded_at: insight.recordedAt,
    owner: insight.owner,
    summary: insight.summary,
    tokens_impacted: insight.tokensImpacted ?? [],
    documents: insight.documents ?? [],
    participants: insight.participants ?? [],
    evidence_url: insight.evidenceUrl ?? null,
    metadata: { version, index }
  }));
}

function sqlString(value) {
  if (value === null || value === undefined) {
    return 'NULL';
  }
  const escaped = String(value).replace(/\\/g, '\\\\').replace(/'/g, "''");
  return `'${escaped}'`;
}

function sqlJson(value) {
  const payload = typeof value === 'string' ? value : JSON.stringify(value ?? {});
  const escaped = payload.replace(/\\/g, '\\\\').replace(/'/g, "''");
  return `CAST('${escaped}' AS JSON)`;
}

function buildInsertStatement(table, columns, rows, updateColumns) {
  if (!rows.length) {
    return `-- No rows for ${table}\n`;
  }
  const values = rows
    .map((row) => `  (${columns.map((column) => row[column]).join(', ')})`)
    .join(',\n');
  const updates = updateColumns
    .map((column) => `  ${column} = VALUES(${column})`)
    .concat(['  updated_at = CURRENT_TIMESTAMP'])
    .join(',\n');
  return `INSERT INTO ${table} (${columns.join(', ')})\nVALUES\n${values}\nON DUPLICATE KEY UPDATE\n${updates};\n`;
}

function buildSqlSeed(tokensJson, researchJson) {
  const tokenRecords = flattenTokenRecords(tokensJson).map((record) => ({
    token_key: sqlString(record.token_key),
    token_value: sqlString(record.token_value),
    source: sqlString(record.source),
    context: sqlString(record.context),
    selector: sqlString(record.selector),
    token_category: sqlString(record.token_category),
    display_order: String(record.display_order ?? 0),
    metadata: sqlJson(record.metadata)
  }));

  const researchRecords = buildResearchRecords(researchJson).map((record) => ({
    slug: sqlString(record.slug),
    title: sqlString(record.title),
    status: sqlString(record.status),
    recorded_at: sqlString(record.recorded_at),
    owner: sqlString(record.owner),
    summary: sqlString(record.summary),
    tokens_impacted: sqlJson(record.tokens_impacted),
    documents: sqlJson(record.documents),
    participants: sqlJson(record.participants),
    evidence_url: sqlString(record.evidence_url),
    metadata: sqlJson(record.metadata)
  }));

  const tokenInsert = buildInsertStatement(
    'design_system_tokens',
    [
      'token_key',
      'token_value',
      'source',
      'context',
      'selector',
      'token_category',
      'display_order',
      'metadata'
    ],
    tokenRecords,
    ['token_value', 'source', 'context', 'selector', 'token_category', 'display_order', 'metadata']
  );

  const researchInsert = buildInsertStatement(
    'ux_research_insights',
    [
      'slug',
      'title',
      'status',
      'recorded_at',
      'owner',
      'summary',
      'tokens_impacted',
      'documents',
      'participants',
      'evidence_url',
      'metadata'
    ],
    researchRecords,
    [
      'title',
      'status',
      'recorded_at',
      'owner',
      'summary',
      'tokens_impacted',
      'documents',
      'participants',
      'evidence_url',
      'metadata'
    ]
  );

  return [
    '-- AUTO-GENERATED FILE. Update docs/design-system/design_tokens.json or research_insights.json and rerun sync-design-tokens.',
    'DELETE FROM design_system_tokens;',
    tokenInsert,
    '',
    'DELETE FROM ux_research_insights;',
    researchInsert,
    ''
  ]
    .join('\n')
    .replace(/\n{3,}/g, '\n\n');
}

fs.writeFileSync(cssOutputPath, buildCss(tokens));
fs.mkdirSync(path.dirname(dartOutputPath), { recursive: true });
fs.writeFileSync(dartOutputPath, buildDart(tokens));
fs.mkdirSync(path.dirname(sqlSeedOutputPath), { recursive: true });
fs.writeFileSync(sqlSeedOutputPath, buildSqlSeed(tokens, researchInsights));

console.log('Design tokens synced to CSS, Flutter outputs, and SQL seed.');
