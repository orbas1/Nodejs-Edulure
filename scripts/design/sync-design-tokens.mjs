import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, '..', '..');

const CSS_SOURCE = path.resolve(ROOT_DIR, 'frontend-reactjs', 'src', 'styles', 'tokens.css');
const DOCS_OUTPUT = path.resolve(ROOT_DIR, 'docs', 'design-system', 'tokens.generated.json');
const FRONTEND_OUTPUT = path.resolve(ROOT_DIR, 'frontend-reactjs', 'src', 'data', 'designTokens.generated.json');
const FLUTTER_OUTPUT = path.resolve(ROOT_DIR, 'Edulure-Flutter', 'lib', 'theme', 'design_tokens.dart');
const RESEARCH_SOURCE = path.resolve(ROOT_DIR, 'docs', 'design-system', 'ux_research_insights.json');
const FRONTEND_RESEARCH_OUTPUT = path.resolve(
  ROOT_DIR,
  'frontend-reactjs',
  'src',
  'data',
  'uxResearchInsights.generated.json'
);

const HEADER_COMMENT = '// Generated by scripts/design/sync-design-tokens.mjs â€” do not edit by hand.\n';

async function readCss() {
  try {
    return await fs.readFile(CSS_SOURCE, 'utf8');
  } catch (error) {
    throw new Error(`Unable to read CSS token source at ${CSS_SOURCE}: ${error.message}`);
  }
}

function normaliseGroup(label) {
  if (!label) {
    return 'General';
  }
  return label.replace(/^[*#\s.-]+/gu, '').replace(/\*\/$/u, '').trim();
}

function parseTokenLine(line) {
  const match = line.match(/--([a-z0-9-]+)\s*:\s*([^;]+);/iu);
  if (!match) {
    return null;
  }
  return {
    name: `--${match[1].trim()}`,
    value: match[2].trim()
  };
}

function parseCssTokens(css) {
  const rootMatches = [...css.matchAll(/:root\s*\{([\s\S]*?)\}/gu)];
  if (rootMatches.length === 0) {
    throw new Error('No :root token blocks were found in tokens.css.');
  }

  const modes = ['light', 'dark'];
  const results = [];

  rootMatches.forEach((match, index) => {
    const rawBlock = match[1];
    const mode = modes[index] ?? `mode-${index}`;
    const lines = rawBlock.split(/\r?\n/);
    let group = 'General';

    for (const rawLine of lines) {
      const line = rawLine.trim();
      if (!line) {
        continue;
      }
      if (line.startsWith('/*') && line.endsWith('*/')) {
        group = normaliseGroup(line.slice(2, -2));
        continue;
      }
      const token = parseTokenLine(line);
      if (token) {
        results.push({
          mode,
          group,
          ...token
        });
      }
    }
  });

  const modeOrder = new Map([
    ['light', 0],
    ['dark', 1]
  ]);

  const tokens = results.sort((a, b) => {
    if (a.mode !== b.mode) {
      const orderA = modeOrder.get(a.mode) ?? Number.MAX_SAFE_INTEGER;
      const orderB = modeOrder.get(b.mode) ?? Number.MAX_SAFE_INTEGER;
      return orderA - orderB;
    }
    if (a.group !== b.group) {
      return a.group.localeCompare(b.group);
    }
    return a.name.localeCompare(b.name);
  });

  const summary = tokens.reduce(
    (acc, token) => {
      const key = `${token.mode}:${token.group}`;
      acc.groupCounts[key] = (acc.groupCounts[key] ?? 0) + 1;
      acc.modeCounts[token.mode] = (acc.modeCounts[token.mode] ?? 0) + 1;
      return acc;
    },
    { groupCounts: {}, modeCounts: {} }
  );

  return { tokens, summary };
}

function serialiseJson(manifest) {
  return `${JSON.stringify(manifest, null, 2)}\n`;
}

function mapTokensByMode(tokens) {
  return tokens.reduce((acc, token) => {
    const bucket = acc[token.mode] ?? (acc[token.mode] = {});
    bucket[token.name] = token.value;
    return acc;
  }, {});
}

function generateDart(tokens) {
  const tokensByMode = mapTokensByMode(tokens);
  const dartLines = [
    'class DesignTokenCatalog {',
    '  const DesignTokenCatalog(this.mode, this.name, this.value, this.group);',
    '  final String mode;',
    '  final String name;',
    '  final String value;',
    '  final String group;',
    '}',
    '',
    'const Map<String, Map<String, String>> kDesignTokenMap = {'
  ];

  const modeEntries = Object.entries(tokensByMode)
    .map(([mode, entries]) => {
      const inner = Object.entries(entries)
        .map(([name, value]) => `    '${name}': '${value.replace(/'/gu, "\\'")}',`)
        .join('\n');
      return `  '${mode}': {\n${inner}\n  }`;
    })
    .join(',\n');

  dartLines.push(modeEntries);
  dartLines.push('};\n');

  dartLines.push('const List<DesignTokenCatalog> kDesignTokens = [');
  tokens.forEach((token) => {
    dartLines.push(
      `  DesignTokenCatalog('${token.mode}', '${token.name}', '${token.value.replace(/'/gu, "\\'")}', '${token.group.replace(/'/gu, "\\'")}'),`
    );
  });
  dartLines.push('];\n');

  return dartLines.join('\n');
}

async function ensureDirectories() {
  await fs.mkdir(path.dirname(DOCS_OUTPUT), { recursive: true });
  await fs.mkdir(path.dirname(FRONTEND_OUTPUT), { recursive: true });
  await fs.mkdir(path.dirname(FLUTTER_OUTPUT), { recursive: true });
  await fs.mkdir(path.dirname(FRONTEND_RESEARCH_OUTPUT), { recursive: true });
}

async function writeOutputs({ tokens, summary }) {
  const generatedAt = new Date().toISOString();
  const manifest = {
    generatedAt,
    source: path.relative(ROOT_DIR, CSS_SOURCE),
    tokens,
    summary
  };

  const jsonPayload = serialiseJson(manifest);
  await fs.writeFile(DOCS_OUTPUT, jsonPayload, 'utf8');
  await fs.writeFile(FRONTEND_OUTPUT, jsonPayload, 'utf8');

  const dartPayload = generateDart(tokens);
  await fs.writeFile(FLUTTER_OUTPUT, HEADER_COMMENT + dartPayload, 'utf8');

  try {
    const research = await fs.readFile(RESEARCH_SOURCE, 'utf8');
    await fs.writeFile(FRONTEND_RESEARCH_OUTPUT, research, 'utf8');
  } catch (error) {
    throw new Error(`Unable to synchronise UX research insights: ${error.message}`);
  }
}

async function main() {
  const css = await readCss();
  const parsed = parseCssTokens(css);
  await ensureDirectories();
  await writeOutputs(parsed);
  console.log('Design tokens synchronised successfully.');
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
