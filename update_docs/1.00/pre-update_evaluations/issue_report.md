# Pre-Update Issue Report – Version 1.00

## Backend service completeness and resilience gaps
The backend still exposes an expansive REST and GraphQL surface, yet most controllers, resolvers, schedulers, and realtime namespaces either return mock payloads or reference services that never start. Queue workers, cron hooks, background processors, and BullMQ integrations remain disconnected, so time-based workflows such as payouts, digest emails, compliance escalations, recommendation refreshes, curriculum synchronisation, and retention jobs never execute. Feature flag metadata is pervasive, but bootstrap scripts ship with critical toggles disabled, tenant guards inconsistently applied, and no tooling to seed Redis or the database with defaults, leaving payments, moderation, analytics, and governance APIs dark until an engineer intervenes. GraphQL resolvers import service facades but still contain TODO stubs, realtime sockets lack authenticated channel handlers, and multi-tenant helpers are routinely bypassed, creating brittle customer journeys that leak cross-tenant data and fail silently when downstream services respond in unexpected formats.

Reliance on third-party providers compounds the fragility. Stripe, PayPal, AWS S3, CloudConvert, ClamAV, FFmpeg, MeiliSearch, Google, Microsoft, Twilio, and LMS connectors are declared dependencies but there is no abstraction for sandbox credentials, retries, circuit breakers, or simulated providers. Health checks verify only HTTP responsiveness, background jobs have no dead-letter queues, rate-limiters are inconsistently configured, and PagerDuty/Sentry hooks are not wired, so outages in payments, media ingestion, messaging, or compliance scanning will pass readiness probes and only surface as console logs. Internal SDKs, webhook handlers, and partner callbacks reference legacy endpoints or undocumented payload shapes, breaking interop with the Flutter and React clients. Promised modular deployment, realtime collaboration, and multi-tenant isolation cannot ship until the backend replaces placeholders with tested business logic, delivers contract tests for SDKs and mobile clients, and ensures infrastructure prerequisites are validated before exposing endpoints.

## Data layer fragility, governance, and retention failures
The Knex migration history provisions dozens of tables covering adaptive learning, field services, payouts, governance, analytics, and event sourcing, yet the application rarely seeds or queries them. Conditional `hasTable` guards hide partial failures, migrations lack rollback scripts, seeds fail silently after schema changes, and there are no integrity checks to prevent drift, leaving clean installs without required enums, reference data, or partition tables. Reporting tables and CDC aspirations remain aspirational—materialised views, ETL jobs, and domain event writers are missing, so analytics dashboards, audit exports, and learner progress APIs return empty datasets. Partition management, archival jobs, timezone strategies, and data catalogues exist only in comments, and there is no golden dataset, synthetic QA pack, or schema diff validation to catch drift before production.

Compliance promises are similarly unfulfilled. Sensitive PII, banking details, secrets, and integration keys are stored in plaintext without column-level encryption, masking, or tenancy-enforced constraints. Audit logging is incomplete because most services never write to the `domain_events` table, data retention scripts truncate records without archiving, and disaster recovery lacks tested backup/restore drills. Multi-region residency, per-tenant scoping, differential privacy, and least-privilege roles remain undefined; database credentials grant broad access, replication channels are unencrypted, and privacy tooling for data subject requests is manual SQL. Governance metadata, consent receipts, and lineage tracking are missing, preventing compliance with SOC 2, GDPR, COPPA, FERPA, and contractual expectations until data governance, integrity verification, and retention automation are delivered end-to-end.

## Dependency and supply-chain governance breakdown
Dependency management spans npm workspaces, leftover yarn settings, standalone Flutter projects, Terraform modules, Docker images, and binary prerequisites (ClamAV, FFmpeg, MJML, Chrome, Java) without a unified toolchain. The TypeScript SDK is referenced via local file paths rather than a published workspace package, generated GraphQL/OpenAPI clients drift from backend contracts, and CI lacks Renovate/Dependabot, SBOM generation, licence auditing, or vulnerability scanning. Known CVEs in axios, adm-zip, jsonwebtoken, lodash, react-dev-utils, Firebase plugins, and container base images remain unpatched, while npm audit scripts are wired but never executed. Binary dependencies are undocumented, native addons lack deterministic builds, and Docker images omit required OS libraries, causing frequent `MODULE_NOT_FOUND`, ENOENT, and incompatible libc failures during local setup, container builds, or CI pipelines.

Operational friction follows from the fragmentation. Multiple lint configs, mixed CommonJS/ESM tooling, inconsistent TypeScript versions, and absent lockfile policy make installs non-deterministic. Flutter dependencies expect feature flag keys that the backend never exposes, mobile Firebase/SDK integrations lack documented version matrices, and infrastructure modules pull unpinned Terraform providers at apply time. There is no supply-chain hardening—npm tokens are broad, provenance checks absent, secrets linger in `.npmrc`, GitHub Actions reuse generic runners without hardened images, and dependency health dashboards do not exist. Without a disciplined dependency lifecycle and provenance strategy, the organisation cannot satisfy enterprise procurement requirements or keep pace with roadmap commitments that promise “provider choice” and modular upgrades.

## Front-end operator experience and security deficits
The React admin experience mirrors backend routes but continues to rely on static mock datasets, disconnected multi-step flows, and realtime contexts that never receive events. Payments, onboarding, curriculum authoring, analytics drill-downs, governance approvals, and compliance exports cannot be completed end-to-end because forms lose state, steps lack draft persistence, and backend endpoints either fail or return placeholder data. Navigation registers more than forty sub-routes without progressive disclosure, loading/error treatments vary wildly, and accessibility fundamentals—ARIA roles, focus traps, keyboard navigation, screen reader labelling—are missing despite WCAG compliance commitments. Localization is incomplete, theming tokens are hard-coded, marketplace search facets surface filters unsupported by the backend, and widget rendering fails for tenants using right-to-left locales or custom branding.

Security and integration gaps are equally severe. Session tokens persist in localStorage, CSP and sandboxing guidance is absent, HTML previews render unsanitised markup, and password/2FA flows expose insecure query parameter handoffs. The frontend mixes SDK-generated clients with ad-hoc axios calls, lacks unified retry/backoff behaviour, and does not react to feature flag updates without a reload, so toggles, realtime collaboration, and capability manifests remain theoretical. Error handling assumes consistent payload shapes, resulting in crashes when the backend returns arrays or nulls, and there is no client-side observability (Sentry/RUM) to capture failures. Internal tooling for impersonation, audit trails, and tenant management is stubbed or hidden, preventing support teams from resolving incidents. Without investing in accessibility, usability, instrumentation, and secure storage patterns, the operator dashboard cannot meet enterprise expectations or legal obligations.

## Provider channel discontinuity and operational fallout
The legacy provider mobile app has been retired, yet backend routes, cron jobs, push notification topics, OKRs, marketing collateral, and partner expectations still assume its presence. No migration guide, responsive web replacement, or explicit end-of-life statement exists, leaving providers without scheduling, compliance capture, payout approval, inventory updates, or offline workflows that were contractually promised. Push topics emit warnings because no client subscribes, analytics dashboards report meaningless provider metrics, and partner integrations expecting callbacks receive none. Training materials, knowledge base articles, and escalation matrices still reference in-app chat and task workflows, causing confusion for support teams and field staff who cannot reconcile reality with documentation.

Security and compliance debt accumulates while the channel remains undefined. Dormant provider credentials, Firebase keys, IAM roles, and mobile secrets were never rotated; audit logs omit configuration changes; MFA enforcement is optional; and device management/posture controls tied to the native app disappeared without alternatives. App store listings, documentation, SLAs, and go-to-market messaging still advertise the “provider companion,” exposing the company to reputational and legal risk. Revenue projections, incentives, and partner contracts depend on provider engagement metrics that are now untrackable. Without a replacement plan or decommissioning campaign, partners cannot plan operations, and internal KPIs tied to provider engagement become unattainable.

## Learner mobile instability and unfulfilled commitments
The Flutter learner app exposes a broad navigation surface but depends on mock services, commented monetisation scaffolding, disabled isolates, and feature flags that fail open. Offline caching, background downloads, push notifications, chat, QR attendance, calendar sync, adaptive recommendations, and lesson authoring either crash, no-op, or render “coming soon” toasts, undermining the “mobile companion” narrative. Session bootstrap opens numerous Hive boxes synchronously without fallbacks, navigation lacks deep-link handlers, settings bury critical toggles, localisation is English-only, and UI layouts break under font scaling or smaller devices. Widget tests, golden snapshots, and integration coverage are absent, so regressions reach production unnoticed.

Security posture is equally immature. Tokens persist without refresh flows or device binding, SSL pinning and jailbreak/root detection are absent, feature flags control access client-side without server confirmation, and secure storage falls back to plaintext preferences without user notification. Privacy consent toggles never synchronise with backend records, analytics instrumentation is disabled, crash reporting is misconfigured, and support tooling for device logs or remote assistance does not exist. Marketing promises around offline-first, realtime alerts, personalised insights, accessibility, and compliance-grade record keeping cannot be met until the mobile app implements the requisite integrations, observability, and hardening.

## Cross-platform contract drift and observability shortfalls
Contracts between backend services, generated SDKs, web clients, and mobile apps are drifting unchecked. OpenAPI/GraphQL generation drops dozens of endpoints due to missing annotations, TypeScript SDK packages are unpublished or ship without required peer dependencies, and frontend/mobile clients mix stale models with ad-hoc REST calls. There are no consumer contract tests, schema diff gates, or automated regeneration pipelines, so feature rollouts routinely break clients. Queue workers, schedulers, webhook handlers, and analytics pipelines run without dead-letter queues, retries, circuit breakers, or alerting, leaving teams blind to poison messages and background job failures. Health checks probe only HTTP liveness, not downstream dependencies or infrastructure prerequisites, and observability claims around OpenTelemetry, distributed tracing, RUM, or metrics dashboards are unmet.

Operational tooling is similarly absent. Cron jobs, data retention scripts, infrastructure provisioning, and backup processes lack monitoring; incident response playbooks reference PagerDuty integrations that are not wired; and there is no unified SLO/SLI programme across backend, web, mobile, and data pipelines. Environment bootstrap scripts skip infrastructure validation, causing runtime `ECONNREFUSED` errors when Redis, MeiliSearch, Kafka, or mail relays are missing. Release engineering lacks smoke tests, load tests, or chaos drills, so failures propagate silently. Without rigorous observability, automation, and compatibility testing, the platform cannot achieve the advertised 99.9% uptime or proactive incident management.

## Infrastructure, deployment, and environment parity breakdown
Infrastructure-as-code spans Terraform, Docker Compose, shell scripts, and ad-hoc README steps without a consistent source of truth. Terraform modules reference unpinned providers, omit state backends, and rely on manual variable files, while Docker Compose stacks expose inconsistent environment variables and hard-coded secrets. CI pipelines build images without multi-arch support, skip vulnerability scans, and publish tags manually, making rollbacks and provenance unclear. There is no blue/green or canary deployment strategy, infrastructure validation suite, or automated smoke tests executed post-deploy. Secrets management mixes plaintext `.env` files, AWS Parameter Store, and Firebase console values without rotation policies.

Environment parity issues cascade into delivery risks. Local developers must install Redis, MeiliSearch, Stripe CLIs, Flutter SDKs, Android/iOS toolchains, and Terraform binaries manually, yet provisioning scripts neither verify versions nor provide fallbacks. Staging environments diverge from production in feature flags, seed data, storage buckets, and IAM policies, invalidating test results. Container images omit health probes, resource limits, and startup ordering, so orchestrators restart services endlessly. Without consolidated infrastructure ownership, deterministic environment builds, and formal release gates, deployment remains a manual, error-prone effort incompatible with the organisation’s release ambitions.

## Quality assurance, testing, and release management deficiencies
Automated testing is largely aspirational. Unit tests exist in pockets but are skipped in CI, integration tests reference non-existent fixtures, and end-to-end suites for web and mobile are commented out. Load testing, security scanning, accessibility audits, and localisation checks are absent despite being promised in compliance collateral. Release branches are cut without go/no-go criteria, manual QA lacks scripted test cases, and regression bugs reopen previously “complete” stories because acceptance criteria are unenforced. SDK publishing, mobile store submissions, and infrastructure updates lack coordinated release notes or rollback plans, leaving support teams uninformed when incidents arise.

The release lifecycle is also undocumented. Versioning schemes differ across backend, SDK, web, and mobile repositories, making compatibility unclear. Build pipelines do not sign artefacts, provenance metadata is missing, and there are no dry-run environments to rehearse upgrades. Incident response relies on ad-hoc Slack coordination without postmortem tooling or capacity planning. Until QA coverage, automated gates, and disciplined release management are established, Version 1.00 cannot be considered production-ready.

## Documentation, enablement, and organisational readiness gaps
Contributor onboarding guides remain outdated, referencing deprecated scripts, missing prerequisites, and retired provider/mobile features. API reference docs are generated sporadically and omit authentication, error handling, and tenancy guidance. Support playbooks still assume features that were cut (provider chat, offline sync), while legal, sales, and marketing collateral promise capabilities that do not exist. Internal training lacks enablement decks, sandbox environments, or sample datasets for demos, so go-to-market teams improvise workflows that break under customer scrutiny.

Cross-functional alignment is missing. Product requirement documents, design specs, and engineering work trackers diverge, making it impossible to trace requirements to implementation status. Customer success lacks visibility into feature readiness, compliance teams cannot audit privacy workflows, and finance cannot reconcile revenue forecasts with real monetisation mechanics. Without refreshed documentation, enablement assets, and stakeholder communications, the organisation risks misrepresenting the platform and failing audits, renewals, and enterprise deals.

## Strategic alignment, compliance, and stakeholder risk
Marketing, sales, investor, and roadmap artefacts continue to promise realtime collaboration, AI-personalised learning paths, provider parity, offline resilience, modular deployment, SOC 2 readiness, and enterprise-grade governance. The codebase, however, lacks the implemented functionality, instrumentation, and compliance automation to substantiate those claims. Accessibility statements cite WCAG AA coverage despite missing ARIA semantics; privacy collateral promises right-to-be-forgotten automation while deletion workflows remain manual; and revenue projections assume monetisation flows that are unimplemented across web and mobile. Operational promises around rapid incident response, disaster recovery, and self-serve onboarding are unsupported without feature flag tooling, observability, or containerised environments.

Until the organisation reconciles marketing narratives with engineering reality—through published capability matrices, updated collateral, transparent partner communications, and governance reviews—stakeholders risk making contractual commitments the product cannot meet. The Version 1.00 release would expose the company to reputational damage, legal claims, and customer churn unless these gaps are acknowledged, resourced, and prioritised for remediation.

## Analytics, insights, and data product paralysis
Analytics ambitions span cohort dashboards, adaptive learning feedback loops, financial reconciliations, compliance attestations, and AI-assisted recommendations, yet the plumbing to produce trustworthy insights remains unfinished. Event producers rarely emit structured telemetry, domain events omit correlation identifiers, and the warehouse integration never materialised—no Airbyte/Fivetran pipelines, dbt models, or Lakehouse governance exist. BI workbooks and Looker/Tableau dashboards reference deprecated schemas, leaving product, customer success, and finance teams to manually stitch CSV exports. AI/ML prototypes depend on feature stores and notebook pipelines that are not provisioned in any environment; without model registry, drift monitoring, or reproducible training datasets, promised “AI-powered personalisation” is marketing fiction. Third-party analytics (Amplitude, Mixpanel, Segment) are wired inconsistently across clients, duplicating events and leaking PII due to absent governance, while consent management cannot filter telemetry per jurisdiction.

Downstream consumers inherit the chaos. Executive scorecards pull from spreadsheets maintained by analysts scraping logs, experimentation platforms lack guardrails or statistical governance, and revenue forecasts ignore real payment success rates because settlement data never lands in analytics stores. Compliance audits demand immutable evidence trails, yet audit tables stay empty and warehouse permissions are wide open. Until data products, observability, and governance converge on a coherent analytics platform, leadership decisions rest on anecdote instead of instrumented truth, and contractual reporting obligations will continue to be missed.

## Customer support, training, and field operations readiness gaps
Support tooling trails the product surface by multiple releases. Zendesk and Intercom integrations link to macros describing retired provider features, support agents lack impersonation and safe-mode tooling, and escalation paths reference engineering squads that no longer exist. Knowledge base articles, LMS modules, and training decks were never updated after mobile and provider pivots, leaving frontline teams without scripts for downtime, billing disputes, or compliance submissions. Field operations rely on manual spreadsheets to track fulfilment, and there is no remote diagnostic tooling, log streaming, or safe data access for troubleshooting tenant-specific incidents. SLA management is purely aspirational—no ticket prioritisation rules tie to contractual obligations, and incident communications are improvised in shared Slack channels.

The training backlog compounds the risk. New hires face weeks of shadowing because onboarding portals are broken, sandbox environments lack seeded data for realistic walkthroughs, and certification checklists reference deprecated terminology. Partner enablement teams cannot demonstrate promised workflows during sales or renewal calls, eroding trust. Without refreshed support tooling, updated knowledge assets, and structured training curricula, operational teams will continue escalating avoidable incidents, and customers will perceive the organisation as unprepared for enterprise-grade support.

## Financial operations, monetisation, and contractual exposure
Revenue strategies hinge on subscription billing, usage-based add-ons, marketplace commissions, and provider payouts, yet the underlying systems are stubbed or disabled. Stripe and PayPal integrations do not reconcile invoices, tax rates, or refunds; payouts lack ledger balancing; and financial reporting dashboards never populate because settlement webhooks fail silently. Pricing catalogues remain hard-coded, experiments to meter usage are unimplemented, and revenue recognition schedules cannot be generated without complete transaction histories. Deferred revenue, chargeback, and dispute workflows have no automation, forcing finance teams into manual spreadsheet reconciliations that cannot satisfy audit standards or investor scrutiny.

Contractual commitments extend beyond finance. Service credits, uptime guarantees, data residency clauses, and privacy appendices depend on controls that do not exist. Vendor management has not completed third-party risk assessments or SOC 2 bridge letters for critical providers; procurement documentation is outdated; and legal has no system-of-record for commitments made in side letters or enterprise amendments. Without monetisation plumbing, financial controls, and contract governance, the organisation risks revenue leakage, failed audits, breach of contract claims, and erosion of investor confidence.

## Risk management, governance, and audit readiness deficiencies
Risk management remains ad hoc. There is no enterprise risk register, mitigation tracking, or ownership model across engineering, security, legal, and operations. Business continuity plans are outdated, tabletop exercises never occur, and there is no documented recovery time objective (RTO) or recovery point objective (RPO) mapping to infrastructure capabilities. Vendor access reviews are manual, asset inventories are incomplete, and configuration drift across cloud accounts cannot be audited due to missing CMDB or Infrastructure-as-Code attestation. Privacy impact assessments, DPIAs, and security threat models have not been refreshed since major architectural changes, leaving leadership blind to evolving exposure.

Audit readiness is equally immature. Evidence collection for SOC 2, ISO 27001, or GDPR relies on screenshots and verbal assurances rather than automated control monitoring. Change management lacks approval trails, segregation of duties is unenforced in CI/CD, and privileged access reviews do not occur. Penetration testing findings remain unresolved because there is no remediation tracking or executive sponsorship. Absent a governance programme with board-level visibility, the organisation cannot credibly pursue compliance certifications or reassure enterprise customers demanding audited controls.
