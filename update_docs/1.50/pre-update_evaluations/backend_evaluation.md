# Backend Evaluation – Version 1.50

## Functionality
- **Monolithic route composition without feature isolation.** `app.js` eagerly registers every domain router (auth, communities, runtime config, payments, realtime chat, analytics, courses, admin, ebooks, blog) in one Express instance and always loads the on-disk OpenAPI document. There are no dynamic feature toggles or conditional mounts, so any regression in a single router jeopardises the entire surface area and prevents canary deployments for Version 1.50.【F:backend-nodejs/src/app.js†L14-L138】
- **All services bootstrap synchronously on process start.** `server.js` performs a health query, runs migrations, starts feature flag/config/search services, binds Socket.IO, and launches asset ingestion plus cron jobs inside the HTTP process. Failures anywhere call `process.exit(1)`; there is no readiness gate or phased startup, meaning transient downstream outages crash the API and risk repeated restarts during incidents.【F:backend-nodejs/src/server.js†L1-L55】
- **Operational workloads share the web runtime.** Asset ingestion, data retention, community reminders, realtime, and search refresh live in the same Node process as REST handlers. Because jobs are started via the web server lifecycle, capacity planning for CPU- or IO-heavy tasks competes directly with request handling, limiting horizontal scaling and contradicting the “enterprise” resiliency we promise.【F:backend-nodejs/src/server.js†L27-L55】【F:backend-nodejs/src/jobs/dataRetentionJob.js†L56-L166】
- **Environmental configuration is all-or-nothing.** The env schema insists on complete JWT keysets, Meilisearch hosts, and payment tax tables before boot succeeds; there are no defaults for sandboxing or partial deployments, so teams cannot bring up reduced environments for focused testing without replicating production-level configuration.【F:backend-nodejs/src/config/env.js†L25-L197】
- **Platform state is held entirely in-memory.** Realtime presence, live course chat, feature flag caches, and runtime configuration snapshots all persist inside single-process Maps or Sets. A restart wipes presence, message history, and flag caches, and there is no horizontal scaling strategy because socket rooms, feature refresh intervals, and session registries assume one process.【F:backend-nodejs/src/services/RealtimeService.js†L1-L160】【F:backend-nodejs/src/services/FeatureFlagService.js†L1-L160】
- **API surface lacks versioning or tenant boundaries.** Every router mounts under `/api/*` with no version prefix or tenant scoping, so evolving payloads for enterprise customers requires breaking changes or parallel code paths within the same handlers.【F:backend-nodejs/src/app.js†L92-L138】

## Usability
- **Operational tooling requires expert familiarity.** Metrics output is rich (Prometheus counters for HTTP, storage, antivirus, search, payments), yet there is no simplified operator dashboard or JSON status endpoints. Without Prometheus and Grafana expertise, on-call engineers struggle to interpret system health quickly.【F:backend-nodejs/src/observability/metrics.js†L8-L190】
- **Error handling hides actionable context from integrators.** The error middleware intentionally strips stack traces in production and responds with generic messages, while no correlation identifiers are returned even though request tracing is initialised—debugging client issues therefore depends entirely on log access rather than API responses.【F:backend-nodejs/src/app.js†L55-L118】【F:backend-nodejs/src/middleware/errorHandler.js†L5-L24】
- **Swagger documentation is static and can drift.** The OpenAPI document is read from disk during boot with no runtime validation; new routes or query params can silently diverge from documentation, creating friction for API consumers and partner teams.【F:backend-nodejs/src/app.js†L30-L107】
- **Administrative switches are opaque.** Runtime configuration middleware runs before request handlers, but there is no operator interface for toggling the many jobs or integrations once booted, forcing engineers to edit env vars and redeploy for operational control.【F:backend-nodejs/src/app.js†L55-L118】【F:backend-nodejs/src/server.js†L27-L55】
- **Domain controllers embed complex logic without shared patterns.** Large controllers such as `CourseController` and `AdminSettingsController` mix validation, data access, realtime broadcasting, and HTTP shaping, so maintainers must read hundreds of lines per file to discover expected flows—there is no documented layering or scaffolding for new features.【F:backend-nodejs/src/controllers/CourseController.js†L1-L110】【F:backend-nodejs/src/controllers/AdminSettingsController.js†L1-L200】

## Errors
- **Job orchestration lacks guardrails.** Cron-backed services log and continue on failure without paging or exponential back-off, while `DataRetentionJob` only pauses after repeated errors and still relies on in-process state; a crash resets counters, so flaky policies can thrash the system indefinitely.【F:backend-nodejs/src/jobs/dataRetentionJob.js†L56-L166】
- **Startup failures exit brutally without remediation.** Database migrations run automatically, but if a migration partially succeeds the process terminates, leaving schema drift and no automated rollback or notification to stakeholders. Similar `process.exit` usage after feature flag or search initialisation increases MTTR because failures require manual investigation before the service restarts cleanly.【F:backend-nodejs/src/server.js†L14-L55】
- **Downstream integrations lack defensive resilience.** Payment, storage, conversion, and messaging dependencies have no circuit breakers or retry envelopes; when AWS, Stripe, or CloudConvert throw, the API bubbles the error to clients and increments an error counter without isolating faulty providers.【F:backend-nodejs/src/services/FeatureFlagService.js†L141-L199】【F:backend-nodejs/src/app.js†L92-L154】
- **Scheduled migrations and jobs share credentials.** Because the same privileged connection runs schema migrations and background jobs, a single compromised credential enables destructive operations across the data estate with no compartmentalisation.【F:backend-nodejs/src/server.js†L14-L55】
- **Realtime lifecycle errors are swallowed.** Socket authentication failures emit `UNAUTHORIZED` strings without correlation IDs and all subsequent handler errors log a warning but never notify operators; consumers see silent disconnects rather than actionable diagnostics.【F:backend-nodejs/src/services/RealtimeService.js†L37-L115】

## Integration
- **External services are treated as mandatory.** The API exposes Stripe, PayPal, Cloudflare R2, CloudConvert, Meilisearch, and Socket.IO endpoints irrespective of runtime readiness. There are no capability probes or feature flag gates before routes go live, so clients can hit payment or search APIs before credentials are provisioned, generating avoidable failures.【F:backend-nodejs/src/app.js†L92-L154】【F:backend-nodejs/src/server.js†L27-L55】
- **Tight coupling between feature flag infrastructure and HTTP stack.** Feature flag and runtime configuration services are started synchronously and share Prometheus registries with request metrics, making it hard to run them as independent platform services or swap providers later.【F:backend-nodejs/src/services/FeatureFlagService.js†L1-L160】【F:backend-nodejs/src/server.js†L24-L55】
- **Realtime infrastructure is embedded rather than optional.** Socket.IO is initialised against the same HTTP server with no scaling hints; there is no documented path for moving realtime workloads to dedicated nodes or managed services, which becomes a blocker for enterprise customers expecting multi-region failover.【F:backend-nodejs/src/server.js†L27-L55】【F:backend-nodejs/src/services/RealtimeService.js†L1-L160】
- **Session and retention logic cross-contaminate domains.** User session registry, retention jobs, and analytics counters all use the same MySQL connection pool with transactional locking assumptions that break when services are separated into microservices or workers.【F:backend-nodejs/src/services/SessionRegistry.js†L1-L120】【F:backend-nodejs/src/jobs/dataRetentionJob.js†L56-L166】

## Security
- **CORS and authentication posture depend on precise env tuning.** Origins are validated against a Set derived from `env.app.corsOrigins`, and misconfiguration throws 403 errors without safe defaults; combined with optional legacy `JWT_SECRET` fallback, production hardening relies on careful secret rotation and review cycles.【F:backend-nodejs/src/app.js†L55-L118】【F:backend-nodejs/src/config/env.js†L25-L96】
- **Elevated database access at runtime.** Automatic migrations require schema-altering privileges on every deployment, expanding the blast radius if the runtime is compromised. There is no migration proxy or schema-only service account split to mitigate this risk.【F:backend-nodejs/src/server.js†L14-L22】
- **Operational data lacks least-privilege segmentation.** Feature flag, runtime config, analytics, and payment services share the same credential scope and metrics registry; compromise of one integration could leak telemetry or runtime secrets because there is no compartmentalised secret store or per-service IAM boundary.【F:backend-nodejs/src/services/FeatureFlagService.js†L1-L160】【F:backend-nodejs/src/observability/metrics.js†L92-L190】
- **Realtime service leaks personal data to third parties.** Avatar URLs are generated via DiceBear using user names and seeded parameters, effectively disclosing identifiable information to an external API for every connection without opt-out controls.【F:backend-nodejs/src/services/RealtimeService.js†L12-L44】

## Alignment
- **Platform vision outpaces deployment maturity.** The backend aspires to be a unified platform with feature flags, realtime, analytics, and asset ingestion, yet the absence of modular service boundaries or staged rollouts contradicts the Version 1.50 goal of predictable enterprise delivery.【F:backend-nodejs/src/app.js†L14-L138】【F:backend-nodejs/src/server.js†L1-L55】
- **Operational narratives lack supporting automation.** Documentation and scripts promise retention automation, runtime config, and payment observability, but we are missing automated health gates, dependency isolation, and admin tooling to align reality with those promises.【F:backend-nodejs/src/jobs/dataRetentionJob.js†L56-L166】【F:backend-nodejs/src/services/FeatureFlagService.js†L1-L199】
- **Data modelling and realtime state contradict resilience messaging.** Critical context (sessions, live presence, flag cache) resets whenever the process restarts, undercutting claims of enterprise continuity and hindering any multi-region strategy for Version 1.50.【F:backend-nodejs/src/services/RealtimeService.js†L1-L160】【F:backend-nodejs/src/services/FeatureFlagService.js†L1-L160】
- **Recommended focus for the update.** Split job runners from the API, introduce readiness/liveness probes, add per-integration capability checks, move realtime/flag caches to durable stores, and harden credential separation to match enterprise expectations for reliability and governance in 1.50.
