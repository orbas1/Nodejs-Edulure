# Issue Report – Version 1.50 Pre-Update Evaluations

## 1. Backend platform couples every integration with the web runtime
The Express app mounts all feature routers, observability middleware, and documentation in a single process without any feature gating or modular entry points. One regression affects the entire API surface because routes for auth, payments, analytics, realtime chat, ebooks, and blogs are always loaded together.【F:backend-nodejs/src/app.js†L14-L138】 Startup then runs migrations, boots feature flag/runtime/search services, attaches Socket.IO, and launches cron-style jobs during the HTTP server initialisation. Any transient failure during this sequence exits the process, leaving no readiness gating or degraded mode for downstream outages.【F:backend-nodejs/src/server.js†L1-L55】 Background workloads such as the data retention scheduler run inside the same process, so operational spikes compete with request handling and there are no guardrails beyond in-process counters when jobs begin to fail.【F:backend-nodejs/src/jobs/dataRetentionJob.js†L56-L166】 Platform state—feature flags, runtime config, realtime presence—lives entirely in memory, so restarts wipe caches, disrupt live classrooms, and prevent horizontal scaling strategies demanded by enterprise customers.【F:backend-nodejs/src/services/RealtimeService.js†L1-L160】【F:backend-nodejs/src/services/FeatureFlagService.js†L1-L160】

## 2. Database architecture is monolithic and hard to govern
The primary migration creates a single MySQL schema containing communities, tutoring, payments, analytics, KYC, field services, and realtime support tables, leaving no natural boundary for sharding or per-feature rollouts.【F:backend-nodejs/migrations/20241010120000_initial_schema.js†L1-L198】 Seeds reset nearly every table and reinsert administrator/instructor personas with demo credentials, making it impossible to reseed only a subset of modules or keep deterministic IDs across environments.【F:backend-nodejs/seeds/001_bootstrap.js†L7-L198】 Because migrations lack explicit rollbacks and the knexfile requires production-like credentials at import time, environments are prone to drift or startup failure if secrets are not present during CI.【F:backend-nodejs/migrations/20241010120000_initial_schema.js†L1-L52】【F:backend-nodejs/knexfile.cjs†L1-L32】 Sensitive data such as KYC documents and payment ledgers live in plain tables without encryption or audit triggers, while predictable demo passwords remain in seeds, contradicting compliance messaging.【F:backend-nodejs/migrations/20241010120000_initial_schema.js†L90-L198】【F:backend-nodejs/seeds/001_bootstrap.js†L78-L198】 High-volume analytics tables also lack composite indexes, threatening performance once real telemetry lands.【F:backend-nodejs/migrations/20241010120000_initial_schema.js†L65-L198】

## 3. Dependency strategy inflates attack surface and slows upgrades
Workspace scripts strictly enforce Node 20.12.2/npm 10.5.0 and fail when alternative package managers run, yet there is no automation (e.g., `.nvmrc`, Renovate) to keep runtimes current.【F:package.json†L6-L27】【F:scripts/verify-node-version.mjs†L60-L122】 Backend packages always install AWS SDK v3, Stripe, PayPal, CloudConvert, antivirus scanning, Socket.IO, and Prometheus, while the React and Flutter clients bundle analytics and Firebase stacks regardless of feature enablement.【F:backend-nodejs/package.json†L27-L73】【F:frontend-reactjs/package.json†L18-L48】【F:Edulure-Flutter/pubspec.yaml†L1-L64】 Security posture remains reactive: audits run at install time but there are no allowlists, SBOMs, or automated dependency updates, and the backend still allows a legacy `JWT_SECRET` fallback that weakens key rotation.【F:package.json†L15-L23】【F:backend-nodejs/src/config/env.js†L25-L96】 Version skew between Socket.IO client/server packages can introduce runtime incompatibilities with no detection mechanism.【F:backend-nodejs/package.json†L27-L61】【F:frontend-reactjs/package.json†L18-L33】

## 4. Frontend experience lacks resilience, observability, and accessibility
The React bundle ships all personas in one router tree, guarded only by client-side `ProtectedRoute` checks, so every visitor downloads instructor dashboards, analytics, and ads even if they only need marketing pages.【F:frontend-reactjs/src/App.jsx†L1-L160】 Provider nesting in `main.jsx` means failures in auth, runtime config, realtime, or dashboard contexts block initial render with no suspense fallbacks or error boundaries, leading to blank screens during outages.【F:frontend-reactjs/src/main.jsx†L1-L27】 Tokens remain in `localStorage`, protected routes silently redirect unauthorised users to home, and runtime configuration failures are swallowed without banners, making it hard for operators to diagnose incidents or meet security expectations.【F:frontend-reactjs/src/context/AuthContext.jsx†L16-L88】【F:frontend-reactjs/src/components/routing/ProtectedRoute.jsx†L40-L69】【F:frontend-reactjs/src/context/RuntimeConfigContext.jsx†L26-L97】 Navigation and layout files hardcode dozens of options per persona, lack design tokens, and mix presentation with routing logic, impeding tenant customisation and accessibility upgrades.【F:frontend-reactjs/src/layouts/DashboardLayout.jsx†L1-L160】【F:frontend-reactjs/src/styles.css†L1-L200】

## 5. Mobile app startup and data handling lag enterprise standards
The Flutter bootstrap serially initialises storage, telemetry, push notifications, and feature flags, so any subsystem failure prevents the app from rendering and extends cold start times beyond acceptable thresholds.【F:Edulure-Flutter/lib/bootstrap/app_bootstrap.dart†L16-L44】 SessionManager stores tokens securely but leaves profile, dashboard, and download caches in Hive boxes without encryption or logout purging, risking data leakage on shared devices.【F:Edulure-Flutter/lib/services/session_manager.dart†L6-L138】 Push notifications request broad permissions and log Firebase errors silently, while feature flag fetches fail quietly, making staged rollouts unreliable.【F:Edulure-Flutter/lib/services/push_notification_service.dart†L30-L143】【F:Edulure-Flutter/lib/core/feature_flags/feature_flag_notifier.dart†L12-L38】 Routes mirror the entire platform regardless of active features, and there is no persona switching UI, so enterprises cannot tailor the mobile experience or enforce governance policies easily.【F:Edulure-Flutter/lib/main.dart†L23-L94】 Telemetry initialises without consent and offline caches swallow corruption errors, conflicting with compliance and support goals.【F:Edulure-Flutter/lib/bootstrap/app_bootstrap.dart†L16-L44】【F:Edulure-Flutter/lib/services/session_manager.dart†L74-L138】

## 6. Enterprise integration and documentation gaps persist across the stack
None of the stacks provide generated SDKs, SBOMs, or dependency provenance, so partner teams must reverse-engineer API contracts from static OpenAPI files and bespoke Axios/Dio wrappers.【F:backend-nodejs/src/docs/openapi.json†L1-L4000】【F:frontend-reactjs/src/api/httpClient.js†L1-L153】 Observability and audit tooling rely on experts configuring Prometheus/Grafana or inspecting logs manually; there is no admin UI for feature flag health, runtime configuration drift, or realtime status across web and mobile clients.【F:backend-nodejs/src/observability/metrics.js†L8-L190】【F:frontend-reactjs/src/context/RuntimeConfigContext.jsx†L26-L97】【F:Edulure-Flutter/lib/core/feature_flags/feature_flag_notifier.dart†L12-L38】 These gaps undermine the enterprise positioning of Version 1.50 and raise operational risk for launch.

## 7. Provider app scope
A dedicated provider app is not present in this repository, so evaluations focus on the main Flutter user app. If a provider-facing experience is introduced later, it must undergo the same enterprise-level scrutiny described above.
