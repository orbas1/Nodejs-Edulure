# Dependency Evaluation – Version 1.50

## Functionality
- **Rigid workspace runtime requirements hamper adoption.** The root manifest enforces Node ≥20.12.2 and npm ≥10.5.0 via `scripts/verify-node-version.mjs`, immediately terminating installs that do not match the prescribed versions. Contributors on newer LTS streams (e.g., Node 22) must downgrade globally because there is no `.nvmrc` or per-workspace override, which slows security patch uptake.【F:package.json†L6-L27】【F:scripts/verify-node-version.mjs†L60-L122】
- **Backend package pulls every integration unconditionally.** `backend-nodejs/package.json` includes AWS SDK v3, Stripe, PayPal, CloudConvert, antivirus scanning, Socket.IO, and Prometheus whether or not a deployment enables those domains. Minimal or private-cloud editions are forced to install cloud-provider SDKs and payments stacks that may never be used, inflating container size and attack surface.【F:backend-nodejs/package.json†L27-L73】
- **Frontend bundle couples analytics with core navigation.** The React workspace depends on D3, Recharts, and map visualisation libraries even for marketing-only builds; there is no optional peer group or code-splitting profile, so every build inherits heavy visual dependencies regardless of target persona.【F:frontend-reactjs/package.json†L18-L48】
- **Flutter app aggregates broad plugin surface.** `pubspec.yaml` pulls Firebase, local notifications, secure storage, Dio, Hive, Sentry, and EPUB tooling in a single target without separating learner-only from instructor-only flows. This one-size-fits-all dependency graph increases binary size and requires every deployment to configure Firebase even when push is disabled.【F:Edulure-Flutter/pubspec.yaml†L1-L64】
- **Workspace metadata locks npm as the only package manager.** The `packageManager` field and runtime verifier exit when Yarn or pnpm are detected, preventing enterprises from using centrally managed tooling or offline proxies that rely on alternative clients.【F:package.json†L6-L23】【F:scripts/verify-node-version.mjs†L70-L122】

## Usability
- **Workspace commands exist but lack guardrails.** The root scripts fan out lint/test/audit across workspaces, yet there is no automated lockfile consistency check or dedupe step. Developers can commit divergent `package-lock.json` states and only notice once CI fails, slowing collaboration.【F:package.json†L15-L23】
- **Security tooling is present but undiscoverable.** Backend scripts expose `npm run audit:dependencies` and JWT rotation helpers, however there is no documented workflow for SAST/DAST or container scans; teams must manually stitch together tooling, undermining the goal of a batteries-included enterprise platform.【F:backend-nodejs/package.json†L9-L26】
- **Cross-stack coordination is manual.** The Flutter app lacks a `melos` or workspace manager to coordinate with the Node monorepo. Engineers switching from JS to Dart have to manage dependencies in isolation, creating friction and inconsistent versioning norms across teams.【F:Edulure-Flutter/pubspec.yaml†L1-L64】
- **Version pinning is inconsistent.** JavaScript dependencies use caret (`^`) ranges while mobile pins exact versions. Renovations must therefore follow different processes per stack, and there is no documented strategy to keep them aligned across releases.【F:backend-nodejs/package.json†L27-L73】【F:Edulure-Flutter/pubspec.yaml†L1-L64】
- **No asset pipeline for shared components.** React and Flutter both import iconography, fonts, and localisation dictionaries separately. Without a shared package or generated SDK, design updates require manual dependency bumps and duplicate QA across clients.【F:frontend-reactjs/package.json†L18-L48】【F:Edulure-Flutter/pubspec.yaml†L18-L64】

## Errors
- **Automated audits fail noisily on transitive issues.** Mandatory `npm audit --audit-level=moderate` runs on both workspaces, but there are no allowlists for low-risk findings (e.g., EPUB/XML libraries) or instructions on when to suppress. Teams may ignore legitimate CVEs to keep CI green or disable audits entirely.【F:package.json†L15-L23】【F:frontend-reactjs/package.json†L10-L33】
- **Native bindings lack preflight checks.** Dependencies such as `clamav.js` and `mysql2` require system libraries. Without container-level prerequisites or optional install flags, package install errors surface late in CI/CD and are difficult to triage, especially for Windows developers.【F:backend-nodejs/package.json†L27-L61】
- **Mobile plugins can break silently.** Firebase messaging and local notifications demand matching Gradle/CocoaPods versions, yet no lockfiles or setup scripts ship with the repo. Build failures manifest only during native compilation, creating a steep learning curve for new contributors.【F:Edulure-Flutter/pubspec.yaml†L18-L48】
- **Version skew between realtime peers is unmanaged.** The backend and frontend depend on different Socket.IO minor versions (`4.7.5` vs `4.8.1`), so a breaking change upstream could desynchronise protocols without warning. No automated compatibility checks exist across workspaces.【F:backend-nodejs/package.json†L27-L61】【F:frontend-reactjs/package.json†L18-L33】
- **Preinstall guardrails block offline installs.** The runtime verifier requires network access to execute `npm --version` and fails fast when corporate proxies restrict outbound calls. There is no cached version metadata or bypass for air-gapped environments.【F:scripts/verify-node-version.mjs†L60-L100】

## Integration
- **Cloud provider abstractions are missing.** Despite investing in Cloudflare R2 for storage, the backend still installs AWS SDK modules and exposes S3-style operations. There is no toggle to drop AWS when deploying to R2-only environments, complicating compliance in jurisdictions where AWS is disallowed.【F:backend-nodejs/package.json†L27-L61】
- **Payments libraries evolve independently.** Stripe and PayPal SDKs are both required, but the project lacks a shared adapter or version bump cadence. Enterprise merchants will demand simultaneous upgrades, yet we have no governance to ensure parity across providers.【F:backend-nodejs/package.json†L27-L61】
- **Telemetry stacks are siloed.** JavaScript services rely on Prometheus/pino, while Flutter integrates Sentry and custom telemetry observers. Without a unified dependency or shared schema contract, cross-platform tracing is brittle and forces manual correlation across disparate tooling.【F:backend-nodejs/src/observability/metrics.js†L8-L190】【F:Edulure-Flutter/lib/bootstrap/app_bootstrap.dart†L16-L44】
- **Lack of dependency provenance.** There is no SBOM generation or license scanning, so enterprises cannot easily validate compliance. Dependency metadata must be assembled manually, delaying security reviews and vendor onboarding.
- **No shared SDK for API contracts.** Each client reimplements API DTOs because there is no generated TypeScript/Dart package from the OpenAPI spec. Integrations must keep dependencies in sync manually, increasing drift risk.【F:backend-nodejs/src/docs/openapi.json†L1-L4000】【F:frontend-reactjs/src/api/httpClient.js†L1-L153】

## Security
- **Reactive rather than proactive patching.** Critical libraries (`axios`, `jsonwebtoken`, `helmet`, `flutter_secure_storage`) are pinned but not covered by Renovate/Dependabot policies, leaving the platform exposed to CVEs until someone manually notices releases.【F:frontend-reactjs/package.json†L18-L33】【F:backend-nodejs/package.json†L27-L61】【F:Edulure-Flutter/pubspec.yaml†L1-L64】
- **Legacy JWT fallback expands attack surface.** The env configuration still allows a single `JWT_SECRET` string instead of enforcing key rotation, meaning dependency upgrades alone cannot guarantee token security without additional tooling to rotate secrets automatically.【F:backend-nodejs/src/config/env.js†L25-L96】
- **Third-party SDK sprawl increases credential scope.** Pulling full AWS, Stripe, PayPal, and Firebase stacks means the runtime must store numerous high-privilege API keys. Without scoped packages or stubbed providers, compromised modules could exfiltrate secrets that are not even used in a given deployment.【F:backend-nodejs/package.json†L27-L61】【F:Edulure-Flutter/pubspec.yaml†L1-L64】
- **No automated dependency policy enforcement.** There is no `npm shrinkwrap`, SPDX reporting, or Git hooks to block vulnerable versions. Security posture depends entirely on manual reviews, which does not meet enterprise procurement expectations.
- **Unvetted CDN dependencies on the frontend.** React imports fonts and icons via npm packages that expect runtime CDN access (`@heroicons`, Google Fonts) without subresource integrity controls, risking supply-chain tampering if registries are compromised.【F:frontend-reactjs/package.json†L18-L48】【F:frontend-reactjs/src/main.jsx†L1-L27】

## Alignment
- **Dependencies reflect ambitious feature coverage but not deployment reality.** The stack aspires to support payments, realtime, analytics, and rich media everywhere, yet customers often roll out features incrementally. Without modular dependency sets, we cannot deliver a slimmed-down MVP for targeted rollouts in Version 1.50.【F:backend-nodejs/package.json†L27-L73】【F:frontend-reactjs/package.json†L18-L48】
- **Lifecycle governance is immature.** There is no roadmap for synchronising library upgrades across backend, frontend, and mobile; release planning will continuously fight dependency drift until automated workflows and compatibility matrices exist.【F:package.json†L6-L27】【F:Edulure-Flutter/pubspec.yaml†L1-L64】
- **Documentation gaps make enterprise onboarding difficult.** Without SBOMs, license reports, or dependency change logs, vendor security assessments cannot be completed quickly, delaying Version 1.50 adoption despite the platform’s enterprise claims.
- **Recommended focus for the update.** Introduce Renovate/Dependabot, define optional dependency bundles per feature set, generate SBOMs, publish API SDKs, and document end-to-end upgrade procedures so the dependency strategy matches enterprise-grade expectations for 1.50.
